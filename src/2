use std::net::{TcpListener, TcpStream};
use std::io::{Error, Write};


fn main() {
    println!("Hello, world!");
    let mut listener: TcpListener = match create_listener() {
        Ok(listener) => listener,
        Err(e) => {
            panic!("{e}");
        },
    };

    // should panic if local_addr cannot be unwraped
    println!("{0}", listener.local_addr().unwrap());


}


fn create_listener() -> Result<TcpListener, Error> 
{
    match TcpListener::bind("127.0.0.1:8080")
    {
        Ok(listener) => return Ok(listener),
        Err(_) => {
            match TcpListener::bind("127.0.0.1:0") {
                Ok(listener) => return Ok(listener),
                Err(e) => return Err(e),
            }
        }
    };
}


fn handle_incoming(listener: &mut TcpListener) 
{
    let mut connections: &mut Vec<TcpStream> = &mut vec!();
    for stream in listener.incoming() {
        let mut connection_list = &mut connections;
        match stream {
            Ok(stream) => handle_connection(stream, &mut connection_list),
            Err(e) => println!("{e}"),
        };
        connection_list.iter().count();
    }
    
}

fn handle_connection(stream: TcpStream, connections: &mut Vec<TcpStream>) -> Result<(), Error>
{
    let new_socket_addr: String = match stream.peer_addr() {
        Ok(address) => address.to_string(),
        Err(e) => return Err(e),
    };

    connections.push(stream);
    for connection in connections {
        let socket: std::net::SocketAddr = match stream.peer_addr() {
            Ok(address) => address,
            Err(e) => return Err(e),
        };

        let ret: String = socket.to_string();
        connection.write(&ret);
    }
    Ok(())
}

